<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Universe Explorer — Interactive Cosmic Map</title>
<meta name="description" content="Explore a procedural universe. Click to zoom to Earth and follow the interactive tutorial."/>
<style>
  /* ========== Basic layout & reset ========== */
  :root{
    --bg:#070814;
    --panel:#0f1724;
    --muted:#9aa7c1;
    --accent:#6aa6ff;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 10% 10%, #07102b 0%, var(--bg) 30%, #000 100%);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#e6eef8}
  #app{height:100vh;display:flex;flex-direction:column;overflow:hidden}
  header.app-header{display:flex;align-items:center;justify-content:space-between;padding:12px 18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-bottom:1px solid rgba(255,255,255,0.02)}
  .brand{display:flex;gap:10px;align-items:center}
  .brand .logo{width:38px;height:38px;border-radius:8px;background:linear-gradient(135deg,var(--accent),#9de0ff);display:flex;align-items:center;justify-content:center;color:#042033;font-weight:700}
  .brand h1{font-size:16px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  button.icon{background:var(--panel);border:1px solid rgba(255,255,255,0.03);color:var(--muted);padding:8px;border-radius:10px;cursor:pointer}
  button.icon:hover{color:white}

  /* Canvas fits area */
  .stage{flex:1;position:relative;display:flex;align-items:stretch;justify-content:stretch;overflow:hidden}
  canvas#universe{width:100%;height:100%;display:block;background:transparent}

  /* UI panels */
  .panel{
    position:absolute;right:18px;top:82px;width:320px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:12px;backdrop-filter: blur(6px);
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  .panel h2{margin:0 0 8px;font-size:14px}
  .small{font-size:13px;color:var(--muted)}

  /* Tutorial overlay */
  .overlay{
    position:absolute;left:18px;bottom:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:12px;width:360px;backdrop-filter: blur(6px);
  }
  .tutorial-controls{display:flex;gap:8px;margin-top:10px;justify-content:flex-end}
  .btn{background:linear-gradient(90deg,var(--accent),#9be0ff);border:0;padding:8px 12px;border-radius:8px;color:#042033;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}

  /* Details card */
  .details{
    position:absolute;left:18px;top:82px;width:340px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:12px;backdrop-filter: blur(6px);box-shadow: 0 8px 40px rgba(2,6,23,0.7);
    display:none;
  }
  .details h3{margin:0 0 6px}
  .attr{font-size:13px;color:var(--muted);margin:6px 0}
  .close{position:absolute;right:8px;top:8px;background:transparent;border:0;color:var(--muted);cursor:pointer;font-size:16px}

  /* Little tooltip for hovered objects */
  .tooltip{
    position:absolute;pointer-events:none;padding:6px 8px;background:#021427;border:1px solid rgba(255,255,255,0.03);font-size:13px;border-radius:8px;color:#9fd3ff;display:none;transform:translate(-50%,-110%);
  }

  /* responsive */
  @media (max-width:900px){
    .panel, .details{right:12px;left:12px;width:unset}
    .overlay{left:12px;right:12px;width:unset}
  }
</style>
</head>
<body>
<div id="app">
  <header class="app-header">
    <div class="brand">
      <div class="logo">U</div>
      <h1>Universe Explorer</h1>
      <div style="margin-left:10px;font-size:13px;color:var(--muted)">Click to begin — we'll start by showing Earth.</div>
    </div>
    <div class="controls">
      <button id="resetBtn" class="icon" title="Reset view">Reset</button>
      <button id="toggleGrid" class="icon" title="Toggle debug grid">Grid</button>
      <button id="aboutBtn" class="icon" title="About">?</button>
    </div>
  </header>

  <div class="stage" id="stage">
    <canvas id="universe"></canvas>

    <div class="overlay" id="tutorial">
      <h2>Welcome to Universe Explorer</h2>
      <div id="t-step" class="small">Click anywhere to show Earth and start the interactive tutorial.</div>
      <div class="tutorial-controls">
        <button id="tutorial-skip" class="btn ghost">Skip</button>
        <button id="tutorial-next" class="btn">Start</button>
      </div>
      <div class="hint">Controls: Drag to pan • Scroll or pinch to zoom • Click objects for details</div>
    </div>

    <div class="panel" id="inspector" style="display:none">
      <h2 id="inspector-title">Inspector</h2>
      <div id="inspector-body" class="small">Select an object to see details</div>
    </div>

    <div class="details" id="details">
      <button class="close" id="details-close">✕</button>
      <h3 id="details-title">Earth</h3>
      <div id="details-body" class="small"></div>
    </div>

    <div class="tooltip" id="tooltip">Object</div>

  </div>
</div>

<script>
/*
  Universe Explorer
  - Canvas rendering with hierarchical procedural universe (galaxies -> stars -> planets)
  - Pan & zoom (mouse/touch)
  - Click anywhere to trigger "zoom to Earth" first event and start tutorial
  - Click objects to open details card
  - Tutorial steps (interactive)
  - Deterministic PRNG for reproducible object attributes
*/

/* ==========================
   Utility: deterministic PRNG
   ========================== */
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}

/* ==========================
   Coordinate system & camera
   ========================== */
const canvas = document.getElementById('universe');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
function resizeCanvas(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(canvas.clientWidth * DPR);
  canvas.height = Math.floor(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// world coordinates are large — we use a center-based camera
let camera = {
  x: 0, // world x at canvas center
  y: 0,
  scale: 0.0006, // world units -> screen pixels
  targetScale: 0.0006,
  easing: 0.12
};

// debug grid toggle
let showGrid = false;

/* ==========================
   Procedural universe data
   ==========================
   We'll create a deterministic universe seeded for reproducibility.
   The universe has:
    - galaxies: positions in world coords, each has many stars
    - stars: position relative to galaxy, brightness, size
    - planets: orbit radius, size, color, atmosphere flag
*/
const UNIVERSE_SEED = 1337;
const rng = mulberry32(UNIVERSE_SEED);

// parameters controlling density
const GALAXY_COUNT = 120;  // number of visible galaxy centers
const GALAXY_SPREAD = 1.2e7; // how far galaxies spread in world units
const MAX_STARS_PER_GALAXY = 160;
const MIN_STARS_PER_GALAXY = 30;

// cache for generated galaxies
const galaxies = [];

/* Helper: deterministic seeded generator per galaxy */
function seededRNGFor(id) {
  // create a seed for each galaxy (string -> number)
  let s = UNIVERSE_SEED ^ (id * 0x9E3779B1);
  return mulberry32((s >>> 0) & 0xffffffff);
}

/* Generate galaxy centers */
(function initGalaxies() {
  for (let i=0;i<GALAXY_COUNT;i++){
    const r = Math.sqrt(rng()) * GALAXY_SPREAD;
    const ang = rng()*Math.PI*2;
    const gx = Math.cos(ang)*r;
    const gy = Math.sin(ang)*r;
    const seed = Math.floor(rng()*1e9)^i;
    const gRNG = seededRNGFor(seed);
    const type = (gRNG() < 0.18) ? 'spiral' : ((gRNG()<0.35) ? 'elliptical' : 'irregular');
    const starCount = Math.floor(MIN_STARS_PER_GALAXY + gRNG()*(MAX_STARS_PER_GALAXY-MIN_STARS_PER_GALAXY));
    const colorBias = gRNG();
    galaxies.push({
      id: i,
      x: gx, y: gy,
      type, starCount, rngSeed: seed, colorBias
    });
  }
})();

/* ==========================
   Special object: Earth (we'll treat Earth as a specific planet attached to one star in a chosen galaxy)
   We'll pick a particular galaxy + star to house Earth deterministically.
*/
const EARTH_LOC = (function pickEarth(){
  // choose a galaxy near origin but not exactly origin
  let best = galaxies[0];
  let bestD = Infinity;
  galaxies.forEach(g => {
    const d = Math.hypot(g.x, g.y);
    if (Math.abs(d - GALAXY_SPREAD*0.25) < bestD) { best = g; bestD = Math.abs(d - GALAXY_SPREAD*0.25); }
  });
  // pick a star index for earth using seeded RNG of that galaxy
  const gr = seededRNGFor(best.rngSeed);
  const starIdx = Math.floor(gr()*Math.min(40, best.starCount));
  return { galaxyId: best.id, starIdx };
})();

/* Function to get stars for a given galaxy index (cached) */
const galaxyStarsCache = new Map();
function getStarsForGalaxy(g) {
  if (galaxyStarsCache.has(g.id)) return galaxyStarsCache.get(g.id);
  const gRNG = seededRNGFor(g.rngSeed);
  const stars = [];
  for (let i=0;i<g.starCount;i++){
    const ang = gRNG()*Math.PI*2;
    // spiral/elliptical/irregular shape
    const radiusBase = (gRNG()**0.9) * 3000 + (g.colorBias*600);
    const offset = (g.type === 'spiral') ? Math.sin(i/6 + gRNG()*10)*600 : (g.type === 'elliptical' ? (gRNG()-0.5)*1200 : (gRNG()-0.5)*2400);
    const r = radiusBase + offset;
    const sx = g.x + Math.cos(ang)*r;
    const sy = g.y + Math.sin(ang)*r;
    // star properties
    const temp = 2500 + gRNG()*8000; // Kelvin
    const size = 12 + Math.pow(gRNG(), 2) * 28; // visual size in world units
    const brightness = 0.6 + gRNG()*1.4; // relative
    stars.push({id: i, x: sx, y: sy, temp, size, brightness, rngSeed: Math.floor(gRNG()*1e9)});
  }
  galaxyStarsCache.set(g.id, stars);
  return stars;
}

/* Function to generate planets for a star (cached) */
const starPlanetsCache = new Map();
function getPlanetsForStar(galaxyId, starIdx, star) {
  const key = galaxyId + ':' + starIdx;
  if (starPlanetsCache.has(key)) return starPlanetsCache.get(key);
  const sr = seededRNGFor(star.rngSeed);
  const planetCount = Math.floor(sr()*6); // 0..5 planets
  const planets = [];
  let baseOrbit = 200 + sr()*400;
  for (let i=0;i<planetCount;i++){
    const orbit = baseOrbit + i*(100 + sr()*260);
    const size = Math.max(4, Math.round((sr()*1.8 + (i===0?0.8:0)) * (8 + sr()*24)));
    const rocky = sr() > 0.45;
    const color = rocky ? (sr()<0.5 ? '#b07c4f' : '#6e8b6a') : (sr()<0.5 ? '#5aa6ff' : '#ffd36a');
    const name = generateName(sr, 3);
    const hab = (!rocky && Math.abs(orbit - 500) < 160) || (rocky && Math.abs(orbit - 300) < 60 && size > 8 && sr()>0.5);
    planets.push({id:i, orbit, size, rocky, color, name, habitable: !!hab});
  }
  starPlanetsCache.set(key, planets);
  return planets;
}

/* Name generator using seeded rng */
function generateName(rngFunc, syllables=2){
  const consonants = ["k","r","t","s","n","m","l","v","z","q","x","b","d","g","p"];
  const vowels = ["a","e","i","o","u","ae","io","ou"];
  let name = '';
  for (let i=0;i<syllables;i++){
    const c = consonants[Math.floor(rngFunc()*consonants.length)];
    const v = vowels[Math.floor(rngFunc()*vowels.length)];
    name += c + v;
  }
  // capitalise
  return name.charAt(0).toUpperCase() + name.slice(1);
}

/* ==========================
   Interaction handling: pan/zoom and object picking
   ========================== */
let isDragging = false;
let dragLast = null;
let momentum = {vx:0, vy:0};
let lastTapTime = 0;
let touchState = {};

// convert world coordinate to screen pixel coordinate
function worldToScreen(wx, wy) {
  const cx = canvas.clientWidth/2;
  const cy = canvas.clientHeight/2;
  const s = camera.scale;
  return { x: cx + (wx - camera.x) * s, y: cy + (wy - camera.y) * s };
}
function screenToWorld(sx, sy) {
  const cx = canvas.clientWidth/2;
  const cy = canvas.clientHeight/2;
  const s = camera.scale;
  return { x: camera.x + (sx - cx) / s, y: camera.y + (sy - cy) / s };
}

/* Pointer events */
canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  dragLast = {x:e.clientX, y:e.clientY};
  canvas.style.cursor = 'grabbing';
});
window.addEventListener('mouseup', (e) => {
  isDragging = false;
  dragLast = null;
  canvas.style.cursor = 'default';
});
window.addEventListener('mousemove', (e) => {
  if (isDragging && dragLast) {
    const dx = (e.clientX - dragLast.x);
    const dy = (e.clientY - dragLast.y);
    // pan camera: translate by dx/scale
    camera.x -= dx / camera.scale;
    camera.y -= dy / camera.scale;
    dragLast = {x:e.clientX, y:e.clientY};
    momentum.vx = -dx;
    momentum.vy = -dy;
  } else {
    // update hover tooltip
    hoverAt(e.clientX, e.clientY);
  }
});

/* Wheel to zoom */
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  // zoom around mouse position
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  const worldBefore = screenToWorld(mouseX, mouseY);
  const factor = Math.exp(-e.deltaY * 0.0016);
  camera.targetScale = Math.max(0.00005, Math.min(0.02, camera.targetScale * factor));
  // compute new camera.x/y so that worldBefore remains under cursor
  const worldAfter = () => screenToWorld(mouseX, mouseY);
  // We'll animate smoothly; but snap camera to keep focus approximately
  // Adjust camera.x/y proportional to scale change:
  camera.x = worldBefore.x - (mouseX - canvas.clientWidth/2)/ (camera.targetScale);
  camera.y = worldBefore.y - (mouseY - canvas.clientHeight/2)/ (camera.targetScale);
});

/* Touch support: pan (one finger) and pinch (two fingers) */
canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    isDragging = true;
    const t = e.touches[0];
    dragLast = {x:t.clientX, y:t.clientY};
  } else if (e.touches.length === 2) {
    isDragging = false;
    const [a,b] = e.touches;
    touchState.dist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
    touchState.mid = {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2};
  }
});
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length === 1 && isDragging) {
    const t = e.touches[0];
    const dx = t.clientX - dragLast.x;
    const dy = t.clientY - dragLast.y;
    camera.x -= dx / camera.scale;
    camera.y -= dy / camera.scale;
    dragLast = {x:t.clientX, y:t.clientY};
  } else if (e.touches.length === 2) {
    const [a,b] = e.touches;
    const dist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
    const mid = {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2};
    const factor = dist / (touchState.dist || dist);
    camera.targetScale = Math.max(0.00005, Math.min(0.02, camera.targetScale * factor));
    // update camera to keep mid anchored
    const worldBefore = screenToWorld(mid.x, mid.y);
    camera.x = worldBefore.x - (mid.x - canvas.clientWidth/2)/(camera.targetScale);
    camera.y = worldBefore.y - (mid.y - canvas.clientHeight/2)/(camera.targetScale);
    touchState.dist = dist;
    touchState.mid = mid;
  }
}, {passive:false});
window.addEventListener('touchend', (e) => {
  if (e.touches.length === 0) {
    isDragging = false; dragLast = null; touchState = {};
  }
});

/* Click / tap for selection and initial actions */
canvas.addEventListener('click', (e) => {
  const now = Date.now();
  // initial click behavior: if tutorial waiting for first click, trigger focus to Earth
  if (!tutorialState.started && !tutorialState.skipped) {
    tutorialStartZoomToEarth();
    return;
  }
  // otherwise pick object under cursor
  const worldPos = screenToWorld(e.clientX, e.clientY);
  const picked = pickObjectAt(worldPos.x, worldPos.y);
  if (picked) {
    openDetailsFor(picked);
  } else {
    // click empty — close details
    closeDetails();
  }
});

/* ==========================
   Picking: find nearest object within threshold depending on zoom level
   ========================== */
function pickObjectAt(wx, wy) {
  // Determine threshold in world units based on camera scale (screen pixels)
  const pixelThreshold = 18; // user-visible radius
  const worldThreshold = pixelThreshold / camera.scale;
  // check planets first (close objects) — but we'd need to search stars near point
  // Use simple search: iterate galaxies, early prune by bounding box
  for (let g of galaxies) {
    const dx = g.x - wx;
    const dy = g.y - wy;
    const dgal = Math.hypot(dx,dy);
    // prune galaxies too far (if camera zoomed in we only need local)
    if (dgal > Math.max(50000, 15000 / camera.scale)) continue;
    const stars = getStarsForGalaxy(g);
    for (let s of stars) {
      const dsx = s.x - wx;
      const dsy = s.y - wy;
      const d = Math.hypot(dsx, dsy);
      if (d < Math.max(6, s.size) + worldThreshold*0.6) {
        // star clicked — but check planets at close zoom
        const planets = getPlanetsForStar(g.id, s.id, s);
        for (let p of planets) {
          // planet world position along star vector — simple circular orbit projection (not animated for pick)
          const angle = 0.3 * p.id + (s.id % 7) * 0.2;
          const px = s.x + Math.cos(angle) * p.orbit;
          const py = s.y + Math.sin(angle) * p.orbit;
          const dp = Math.hypot(px - wx, py - wy);
          if (dp < Math.max(6, p.size) + worldThreshold*0.5) {
            return {type:'planet', galaxy:g, star:s, planet:p, world:{x:px,y:py}};
          }
        }
        // else return star
        return {type:'star', galaxy:g, star:s, world:{x:s.x,y:s.y}};
      }
    }
  }
  // if no star/planet, detect galaxy at larger threshold
  for (let g of galaxies) {
    const d = Math.hypot(g.x-wx, g.y-wy);
    if (d < Math.max(2000, 800 / camera.scale)) {
      return {type:'galaxy', galaxy:g, world:{x:g.x,y:g.y}};
    }
  }
  return null;
}

/* ==========================
   Details panel handling
   ========================== */
const detailsEl = document.getElementById('details');
const detailsTitle = document.getElementById('details-title');
const detailsBody = document.getElementById('details-body');
document.getElementById('details-close').addEventListener('click', closeDetails);

function openDetailsFor(obj) {
  detailsEl.style.display = 'block';
  if (obj.type === 'planet') {
    detailsTitle.textContent = obj.planet.name || 'Planet';
    detailsBody.innerHTML = `
      <div class="attr"><strong>Type:</strong> ${obj.planet.rocky ? 'Rocky' : 'Gas'}</div>
      <div class="attr"><strong>Size:</strong> ${obj.planet.size} km (relative)</div>
      <div class="attr"><strong>Orbit radius:</strong> ${Math.round(obj.planet.orbit)} km</div>
      <div class="attr"><strong>Habitable:</strong> ${obj.planet.habitable ? 'Possibly' : 'No'}</div>
      <div class="attr"><strong>Parent star temp:</strong> ${Math.round(obj.star.temp)} K</div>
      <div style="height:8px"></div>
      <div class="small">Click Reset to zoom back out or continue exploring.</div>
    `;
    // center camera smoothly to the selected planet
    camera.targetX = obj.world.x;
    camera.targetY = obj.world.y;
    camera.targetScale = Math.min(0.004, 0.0025 * Math.max(1, obj.planet.size / 8));
  } else if (obj.type === 'star') {
    detailsTitle.textContent = `Star [#${obj.star.id}]`;
    detailsBody.innerHTML = `
      <div class="attr"><strong>Temp:</strong> ${Math.round(obj.star.temp)} K</div>
      <div class="attr"><strong>Visual size:</strong> ${Math.round(obj.star.size)}</div>
      <div class="attr"><strong>Brightness:</strong> ${obj.star.brightness.toFixed(2)}</div>
      <div class="attr"><strong>Planets:</strong> ${getPlanetsForStar(obj.galaxy.id, obj.star.id, obj.star).length}</div>
    `;
    camera.targetX = obj.world.x;
    camera.targetY = obj.world.y;
    camera.targetScale = Math.min(0.002, 0.0015 * Math.max(1, obj.star.size / 16));
  } else if (obj.type === 'galaxy') {
    detailsTitle.textContent = `Galaxy #${obj.galaxy.id} (${obj.galaxy.type})`;
    detailsBody.innerHTML = `
      <div class="attr"><strong>Stars:</strong> ${obj.galaxy.starCount}</div>
      <div class="attr"><strong>Color bias:</strong> ${obj.galaxy.colorBias.toFixed(2)}</div>
      <div class="attr"><strong>Seed:</strong> ${obj.galaxy.rngSeed}</div>
      <div style="height:8px"></div>
      <div class="small">Zoom in to explore stars and planets inside this galaxy.</div>
    `;
    camera.targetX = obj.world.x;
    camera.targetY = obj.world.y;
    camera.targetScale = Math.min(0.0009, 0.0008 * (1 + Math.random()*0.8));
  }
}

/* Close details */
function closeDetails() {
  detailsEl.style.display = 'none';
}

/* Inspector (small panel) update */
const inspector = document.getElementById('inspector');
function updateInspector(text) {
  if (!text) {
    inspector.style.display = 'none';
    return;
  }
  inspector.style.display = 'block';
  document.getElementById('inspector-title').textContent = text.title || 'Inspector';
  document.getElementById('inspector-body').innerHTML = text.body || '';
}

/* Hover tooltip */
const tooltip = document.getElementById('tooltip');
function hoverAt(sx, sy) {
  const w = screenToWorld(sx, sy);
  const picked = pickObjectAt(w.x, w.y);
  if (picked) {
    tooltip.style.display = 'block';
    tooltip.style.left = sx + 'px';
    tooltip.style.top = sy + 'px';
    tooltip.textContent = picked.type === 'planet' ? (picked.planet.name + ' • Planet') : (picked.type === 'star' ? 'Star' : 'Galaxy');
    updateInspector({title: picked.type.toUpperCase(), body: picked.type === 'planet' ? `<strong>${picked.planet.name}</strong><div class="small">Click for details</div>` : `<div class="small">Click to zoom in</div>`});
  } else {
    tooltip.style.display = 'none';
    updateInspector(null);
  }
}

/* ==========================
   Rendering: draw galaxies, stars, planets based on zoom (level-of-detail)
   ========================== */
function clear() {
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.restore();
}

function drawGrid() {
  if (!showGrid) return;
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  const stepWorld = 500000; // big grid in world units
  // draw lines near camera center
  const cx = canvas.clientWidth/2;
  const cy = canvas.clientHeight/2;
  const s = camera.scale;
  const leftWorld = camera.x - cx/s;
  const rightWorld = camera.x + cx/s;
  const topWorld = camera.y - cy/s;
  const bottomWorld = camera.y + cy/s;
  const startX = Math.floor(leftWorld / stepWorld) * stepWorld;
  const startY = Math.floor(topWorld / stepWorld) * stepWorld;
  for (let x = startX; x <= rightWorld; x += stepWorld) {
    const sx = cx + (x - camera.x) * s;
    ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, canvas.clientHeight); ctx.stroke();
  }
  for (let y = startY; y <= bottomWorld; y += stepWorld) {
    const sy = cy + (y - camera.y) * s;
    ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(canvas.clientWidth, sy); ctx.stroke();
  }
  ctx.restore();
}

/* Draw galaxy as soft blob when zoomed out */
function drawGalaxy(g) {
  const pos = worldToScreen(g.x, g.y);
  const distToCenter = Math.hypot(pos.x - canvas.clientWidth/2, pos.y - canvas.clientHeight/2);
  // visibility cull
  if (pos.x < -200 || pos.x > canvas.clientWidth+200 || pos.y < -200 || pos.y > canvas.clientHeight+200) return;
  const baseRadius = 40 + g.starCount * 0.12;
  const r = baseRadius * Math.max(0.6, camera.scale * 9000);
  // Render soft halo with radial gradient
  const grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(10, r*2));
  // color bias
  const cb = g.colorBias;
  const c1 = `rgba(${120+cb*80|0}, ${180-cb*40|0}, ${255-cb*80|0}, 0.17)`;
  const c2 = `rgba(${70+cb*40|0}, ${100+cb*60|0}, ${180-cb*40|0}, 0.03)`;
  grad.addColorStop(0, c1);
  grad.addColorStop(0.6, c2);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.save();
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, Math.max(16, r*2.2), 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* Draw a star (mid zoom) */
function drawStar(s) {
  const pos = worldToScreen(s.x, s.y);
  // cull
  if (pos.x < -50 || pos.x > canvas.clientWidth+50 || pos.y < -50 || pos.y > canvas.clientHeight+50) return;
  // brightness -> radius
  const screenSize = Math.max(1, s.size * camera.scale * 0.6);
  // color from temp
  const t = s.temp;
  const color = tempToColor(t);
  // glowing halo
  const grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(6, screenSize*8));
  grad.addColorStop(0, hexToRgba(color, 0.95));
  grad.addColorStop(0.5, hexToRgba(color, 0.45));
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.save();
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, Math.max(8, screenSize*6), 0, Math.PI*2);
  ctx.fill();
  // solid core
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, Math.max(1.2, screenSize), 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* Draw planets when zoomed in enough (animated orbit) */
let animTime = 0;
function drawPlanetsForStar(s, galaxyId, starIdx) {
  const planets = getPlanetsForStar(galaxyId, starIdx, s);
  for (let p of planets) {
    // orbit animation
    const angle = animTime * (0.0006 * (1 + p.id*0.34)) + (s.id % 7) * 0.2 + p.id * 0.7;
    const px = s.x + Math.cos(angle) * p.orbit;
    const py = s.y + Math.sin(angle) * p.orbit;
    const pos = worldToScreen(px, py);
    // cull
    if (pos.x < -20 || pos.x > canvas.clientWidth+20 || pos.y < -20 || pos.y > canvas.clientHeight+20) continue;
    // orbit path
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = Math.max(0.2, 0.3);
    const starPos = worldToScreen(s.x, s.y);
    ctx.beginPath();
    ctx.ellipse(starPos.x, starPos.y, Math.abs(p.orbit*camera.scale), Math.abs(p.orbit*camera.scale), 0, 0, Math.PI*2);
    ctx.stroke();
    // draw planet
    ctx.beginPath();
    ctx.fillStyle = p.color;
    ctx.arc(pos.x, pos.y, Math.max(1.2, p.size * camera.scale * 0.9), 0, Math.PI*2);
    ctx.fill();
    // if habitable, draw tiny glow
    if (p.habitable) {
      const g = ctx.createRadialGradient(pos.x,pos.y,0,pos.x,pos.y,Math.max(8, p.size*camera.scale*6));
      g.addColorStop(0, 'rgba(150,230,160,0.18)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g; ctx.beginPath();
      ctx.arc(pos.x,pos.y,Math.max(6, p.size*camera.scale*6),0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
}

/* Utility: temperature (K) to approx color hex */
function tempToColor(k) {
  // approximate: cooler (red/orange) to hotter (white/blue)
  const t = Math.max(1000, Math.min(12000, k));
  const f = (t - 1000) / 11000; // 0..1
  // blend
  const r = Math.floor(255 * Math.min(1, 1.2 - 0.8*f));
  const g = Math.floor(180 + 60*(1 - Math.abs(f-0.5)*1.8));
  const b = Math.floor(200 + 55 * f);
  return `rgb(${r},${g},${b})`;
}
function hexToRgba(hex, alpha) {
  // accept rgb(...) pass-through
  if (hex.startsWith('rgb')) {
    return hex.replace('rgb','rgba').replace(')',`,${alpha})`);
  }
  // simple hex to rgba
  const h = hex.replace('#','');
  const r = parseInt(h.substring(0,2),16);
  const g = parseInt(h.substring(2,4),16);
  const b = parseInt(h.substring(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}

/* Main render loop */
function render() {
  animTime += 16;
  // smooth camera scale
  camera.scale += (camera.targetScale - camera.scale) * camera.easing;
  // smooth camera pos
  if (camera.targetX !== undefined) camera.x += (camera.targetX - camera.x) * camera.easing;
  if (camera.targetY !== undefined) camera.y += (camera.targetY - camera.y) * camera.easing;
  // apply momentum (in screen space), decay
  if (!isDragging) {
    camera.x += (momentum.vx || 0) * 0.004 / Math.max(camera.scale, 0.00005);
    camera.y += (momentum.vy || 0) * 0.004 / Math.max(camera.scale, 0.00005);
    momentum.vx *= 0.93; momentum.vy *= 0.93;
  }

  clear();
  drawGrid();

  // determine LOD by camera.scale
  const lod = camera.scale;
  // Very far: draw galaxies as blobs
  if (lod < 0.00012) {
    // draw only brightest blobs near center
    for (let g of galaxies) drawGalaxy(g);
  } else if (lod < 0.0005) {
    // draw galaxies + some star specks for nearby galaxies
    for (let g of galaxies) {
      drawGalaxy(g);
      // if near to center region, draw some stars (sparse)
      const screenPos = worldToScreen(g.x, g.y);
      if (screenPos.x > -200 && screenPos.x < canvas.clientWidth+200 && screenPos.y > -200 && screenPos.y < canvas.clientHeight+200) {
        const stars = getStarsForGalaxy(g);
        // draw a sample of stars
        for (let i=0;i<Math.min(12, stars.length);i++){
          drawStar(stars[(i*7) % stars.length]);
        }
      }
    }
  } else {
    // mid to close zoom — draw stars and planets when close
    for (let g of galaxies) {
      // cull by screen rect
      const pos = worldToScreen(g.x, g.y);
      if (pos.x < -800 || pos.x > canvas.clientWidth+800 || pos.y < -800 || pos.y > canvas.clientHeight+800) continue;
      const stars = getStarsForGalaxy(g);
      for (let s of stars) {
        drawStar(s);
        // if close enough, draw planets
        if (camera.scale > 0.0009 || (Math.abs(s.x-camera.x) < 50000 && Math.abs(s.y-camera.y) < 50000)) {
          drawPlanetsForStar(s, g.id, s.id);
        }
      }
    }
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* ==========================
   Tutorial: initial click zoom to Earth + interactive steps
   ========================== */
const tutorialEl = document.getElementById('tutorial');
const tutorialNextBtn = document.getElementById('tutorial-next');
const tutorialSkipBtn = document.getElementById('tutorial-skip');
let tutorialState = { started:false, step:0, skipped:false };

tutorialNextBtn.addEventListener('click', () => {
  if (!tutorialState.started) {
    tutorialStartZoomToEarth();
  } else {
    tutorialNext();
  }
});
tutorialSkipBtn.addEventListener('click', () => {
  tutorialEl.style.display = 'none';
  tutorialState.skipped = true;
});

function tutorialStartZoomToEarth() {
  tutorialState.started = true;
  tutorialState.step = 0;
  // Find earth position: derive world pos of earth by using EARTH_LOC star & planets
  const g = galaxies.find(x=>x.id===EARTH_LOC.galaxyId);
  const stars = getStarsForGalaxy(g);
  const s = stars[EARTH_LOC.starIdx % stars.length];
  const planets = getPlanetsForStar(g.id, s.id, s);
  // ensure there is at least one planet; if not, pick a nearby planet from generation
  if (planets.length === 0) {
    // create a tiny fallback planet
    planets.push({id:0, orbit:320, size:10, rocky:true, color:'#6e8b6a', name:'Terra', habitable:true});
  }
  // choose first planet as Earth analog
  const earth = planets[0];
  const angle = 0.3*earth.id + (s.id%7)*0.2;
  const earthPos = { x: s.x + Math.cos(angle) * earth.orbit, y: s.y + Math.sin(angle) * earth.orbit };
  // set camera targets to zoom in to earth
  camera.targetX = earthPos.x;
  camera.targetY = earthPos.y;
  camera.targetScale = 0.0028;
  // update tutorial UI
  tutorialEl.querySelector('#t-step').textContent = 'Focused on Earth — Step 1: Pan around by dragging. Try it now.';
  tutorialNextBtn.textContent = 'Next';
  // show details about Earth in the details card and keep it open
  openDetailsFor({type:'planet', galaxy:g, star:s, planet:earth, world:earthPos});
  // mark step started
  tutorialState.step = 1;

  // after a short time progress to next step automatically if user doesn't interact
  setTimeout(()=> {
    if (tutorialState.step === 1) {
      tutorialEl.querySelector('#t-step').textContent = 'Step 1: Pan around by dragging. When ready press Next.';
    }
  }, 1500);
}

function tutorialNext() {
  tutorialState.step++;
  if (tutorialState.step === 2) {
    tutorialEl.querySelector('#t-step').textContent = 'Step 2: Zoom in/out using your mouse wheel or pinch gestures.';
    // make camera target scale a bit larger to let them zoom out
    camera.targetScale = 0.0012;
  } else if (tutorialState.step === 3) {
    tutorialEl.querySelector('#t-step').textContent = 'Step 3: Click a star or planet to open its detail card. Try clicking the star near Earth.';
    // ensure camera scale allows clicking stars
    camera.targetScale = 0.0018;
  } else if (tutorialState.step === 4) {
    tutorialEl.querySelector('#t-step').textContent = 'Step 4: Explore galaxies — zoom out and click a galaxy to jump there.';
    camera.targetScale = 0.00018;
    camera.targetX = 0;
    camera.targetY = 0;
  } else {
    tutorialEl.querySelector('#t-step').textContent = 'Tutorial finished. You can re-open this by clicking "?" at the top.';
    tutorialNextBtn.textContent = 'Done';
    setTimeout(()=>{ tutorialEl.style.display = 'none'; }, 1200);
  }
}

/* About button to re-open tutorial / info */
document.getElementById('aboutBtn').addEventListener('click', () => {
  tutorialEl.style.display = 'block';
  tutorialState.started = false;
  tutorialState.skipped = false;
  tutorialEl.querySelector('#t-step').textContent = 'Click anywhere to show Earth and start the interactive tutorial.';
  tutorialNextBtn.textContent = 'Start';
});

/* Reset & grid toggle controls */
document.getElementById('resetBtn').addEventListener('click', () => {
  camera.targetX = 0; camera.targetY = 0; camera.targetScale = 0.0006;
  closeDetails();
});
document.getElementById('toggleGrid').addEventListener('click', () => {
  showGrid = !showGrid;
});

/* ==========================
   Utility: anim loop already running
   ========================== */

/* ==========================
   Small polish: initial hint pulse and accessibility
   ========================== */
(function initUI(){
  // keyboard: Esc closes details/tutorial
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeDetails();
      tutorialEl.style.display = 'none';
    }
  });
  // prepare inspector hidden initially
  updateInspector(null);

  // display Earth hint near first click (UI already prompts)
})();

/* ==========================
   Helper: render size & scale on load to adjust camera
   ========================== */
(function fitOnLoad(){
  // align camera so that the Earth galaxy is roughly near center
  camera.x = 0; camera.y = 0; camera.scale = 0.0006; camera.targetScale = 0.0006;
})();

/* Expose some functions for debugging/console use */
window._UE = {
  galaxies, getStarsForGalaxy, getPlanetsForStar, pickObjectAt, openDetailsFor
};
</script>
</body>
</html>
